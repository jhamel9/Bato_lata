<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Bato Lata</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        :root{
            --bg:#2c3e50;
            --panel:#34495e;
            --accent:#0f3460;
            --glass:rgba(0,0,0,0.45);
        }
        html,body{
            height:100%;
            margin:0;
            font-family: 'Inter', sans-serif;
            background:var(--bg); /* Reverted to original background color */
            color:#e0e0e0;
            display:flex;
            align-items:center;
            justify-content:center;
            overflow: hidden; /* Prevent scrolling on mobile */
        }
        
        #help-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            /* Using an inline SVG for the help icon */
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.43 12.92 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.35 1.7-.92 2.25z"/></svg>') no-repeat center/cover;
            cursor: pointer;
            filter: drop-shadow(0px 0px 3px rgba(0,0,0,0.5)); /* Added subtle shadow */
            z-index: 150; /* Ensure it's above other game elements but below overlays */
        }
        #help-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 200; /* Ensure it's above other elements */
        }
        #help-content {
            max-width: 500px;
            text-align: center;
            background: var(--panel);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }
        #help-overlay button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            background: #3498db;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #help-overlay button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        .game-wrap{
            position:relative;
            display:flex;
            flex-direction:column;
            align-items:center;
            width: 100%; /* Make game-wrap responsive */
            max-width: 500px; /* Constrain max width for desktop */
            height: 100%; /* Make game-wrap responsive */
            max-height: 650px; /* Constrain max height for desktop */
        }
        h1{
            margin:12px 0 0 0;
            font-weight:700;
            text-shadow:2px 2px 4px rgba(0,0,0,0.4);
        }
        canvas{
            display:block;
            border:4px solid var(--accent);
            border-radius:12px;
            box-shadow:0 8px 24px rgba(0,0,0,0.6);
            margin:16px 0;
            width: 100%; /* Canvas takes full width of its container */
            height: auto; /* Maintain aspect ratio */
            flex-grow: 1; /* Allow canvas to grow */
        }
        .score-board{
            position:absolute;
            top:14px;
            left:14px;
            font-size:1.1rem;
            font-weight:700;
            background:var(--glass);
            padding:8px 12px;
            border-radius:8px;
            backdrop-filter: blur(4px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4); /* Added shadow */
            z-index: 10; /* Ensure score is above canvas */
        }
        .message-box{
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%);
            background:var(--panel);
            color:#fff;
            padding:24px 28px;
            border-radius:12px;
            border: 3px solid white; /* Added white border */
            box-shadow:0 6px 20px rgba(0,0,0,0.5);
            text-align:center;
            font-size:1.5rem; /* Increased general font size for message box */
            display:none;
            z-index:100;
        }
        .message-box button{
            margin-top:12px;
            padding:10px 16px; /* Increased padding for better touch target */
            border-radius:10px; /* More rounded corners */
            border:none;
            background:#3498db;
            color:#fff;
            cursor:pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Button shadow */
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Smooth transition */
        }
        .message-box button:hover {
            transform: translateY(-2px); /* Lift effect on hover */
            box-shadow: 0 6px 12px rgba(0,0,0,0.4); /* Enhanced shadow on hover */
        }
        .instructions{
            position:absolute;
            right:14px;
            top:14px;
            background:var(--glass);
            padding:10px 12px;border-radius:8px;font-size:0.9rem;
        }
        .overlay-start{
            position:absolute;
            inset:0;
            display:flex;
            flex-direction: column; /* Changed to column for vertical alignment */
            align-items:center;
            justify-content:center;
            background-size: cover; /* Cover the entire area */
            background-position: center; /* Center the image */
            background-repeat: no-repeat; /* Do not repeat */
            z-index:120;
            color: #fff; /* Ensure text is visible on background image */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6); /* Add text shadow for readability */
            /* The image source will be set in JS */
        }
        .overlay-card{
            background:rgba(0,0,0,0.6); /* Slightly darker, more transparent background */
            padding:20px 30px;
            border-radius:12px;
            text-align:center;
            box-shadow:0 8px 30px rgba(0,0,0,0.8);
            display: flex; /* Use flexbox for internal arrangement */
            flex-direction: column;
            justify-content: flex-end; /* Push content to the bottom */
            align-items: center;
            height: 100%; /* Take full height of overlay-start */
            width: 100%; /* Take full width of overlay-start */
            box-sizing: border-box; /* Include padding in width/height */
            padding-bottom: 50px; /* Add more padding at the bottom for controls */
        }
        .overlay-card h2{
            font-family: 'Press Start 2P', cursive; /* Apply pixel font */
            font-size: 2.2em; /* Larger title */
            margin-bottom: 8px; /* Reduced margin */
            color: #ffeb3b; /* Yellowish title */
            text-shadow: 0 0 8px rgba(255,255,0,0.8); /* Glow effect */
        }
        .overlay-card p{
            font-family: 'Press Start 2P', cursive; /* Apply pixel font */
            font-size: 0.8em; /* Smaller, readable text */
            line-height: 1.6;
            max-width: 80%; /* Limit width for readability */
            margin: 10px auto 30px auto; /* Adjust margins */
        }
        .overlay-card button{
            margin-top:12px;
            padding:10px 20px; /* Slightly larger button */
            border-radius:10px;
            border:none;
            background:#2ecc71;
            color:#fff;
            cursor:pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Button shadow */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-family: 'Press Start 2P', cursive; /* Apply pixel font */
            font-size: 1.1em; /* Button text size */
        }
        .overlay-card button:hover {
            transform: translateY(-2px); /* Lift effect on hover */
            box-shadow: 0 6px 12px rgba(0,0,0,0.4); /* Enhanced shadow on hover */
        }

        /* Mobile Controls - Fullscreen, Joystick, Throw Button */
        .mobile-controls-container {
            display: none; /* Hidden by default, shown/hidden by JS */
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            height: 120px; /* Area for controls */
            z-index: 150;
        }

        .joystick-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100px; /* Size of the joystick area */
            height: 100px;
            background: rgba(128, 128, 128, 0.2); /* Semi-transparent gray */
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4); /* Semi-transparent white border */
        }

        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.6); /* White, more opaque thumb */
            border-radius: 50%;
            pointer-events: none; /* Allow events to pass to the parent joystick-area */
        }

        #mobile-throw-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 80px;
            height: 80px;
            background: rgba(128, 128, 128, 0.4); /* Semi-transparent gray */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Using slipper.png as background image */
            background-image: url('slipper.png');
            background-size: 60%; /* Adjust size of slipper inside button */
            background-position: center;
            background-repeat: no-repeat;
            font-size: 0; /* Hide any default text/emoji */
            color: transparent; /* Hide any default text/emoji */
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            user-select: none;
            cursor: pointer;
            transition: background 0.1s ease;
        }
        #mobile-throw-btn:active {
            background: rgba(128, 128, 128, 0.6);
            transform: scale(0.95);
        }

        #fullscreen-btn {
            display: none; /* Hidden by default, shown on mobile */
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(52, 152, 219, 0.8); /* Blue, semi-transparent */
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            font-size: 0.9em;
            cursor: pointer;
            z-index: 150;
            transition: background 0.2s ease;
        }
        #fullscreen-btn:hover {
            background: rgba(52, 152, 219, 1);
        }

        /* Media queries for mobile display */
        @media (max-width: 768px) {
            .game-wrap {
                width: 100vw; /* Take full viewport width */
                height: 100vh; /* Take full viewport height */
                border-radius: 0; /* No border radius in full screen */
                margin: 0;
            }
            canvas {
                border-radius: 0; /* No border radius for canvas in full screen */
            }
            .score-board {
                font-size: 1.2rem;
                padding: 10px 15px;
            }
            #help-icon {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
            }
            #fullscreen-btn {
                display: block; /* Show fullscreen button on mobile */
            }
            /* The mobile-controls-container's display is now controlled by JS, not this media query */
            /* .mobile-controls-container { display: block; } */
            .overlay-start {
                padding: 0;
            }
            .overlay-card {
                padding-bottom: 30px; /* Adjust padding for mobile layout */
            }
            .message-box {
                font-size: 1.2rem;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="help-icon"></div>
    <div id="fullscreen-btn">Go Fullscreen</div>

<div id="help-overlay">
  <div id="help-content">
    <h2>How to Play</h2>
    <p>Move with WASD or Arrow Keys.<br>
        Press SPACE to throw the slipper.<br>
        Knock down the can to score points.<br>
        Avoid getting caught by the NPC.<br>
        Press P to pause and R to restart.<br>
        Mobile: Use on-screen joystick and throw button.</p>
    <button id="close-help">Close</button>
  </div>
</div>
    <div class="game-wrap">
        <div class="score-board">Score: <span id="scoreValue">0</span></div>
        <canvas id="gameCanvas"></canvas>

        <div id="messageBox" class="message-box"></div>

        <div id="startOverlay" class="overlay-start">
            <div class="overlay-card">
                <h2>Bato Lata</h2>
                <p>Move with WASD or Arrow keys. Press SPACE to throw the slipper toward the can. Bring back the slipper after hitting the can to score. Don't let the guard catch you!</p>
                <button id="startBtn">Start Game</button>
            </div>
        </div>

        <div class="mobile-controls-container" id="mobileControlsContainer">
            <div class="joystick-area" id="joystickArea">
                <div class="joystick-thumb" id="joystickThumb"></div>
            </div>
            <div id="mobile-throw-btn"></div>
        </div>
    </div>

    <script>
    // =====================
    // Config & State
    // =====================
    const config = {
        canvasWidth: 500,
        canvasHeight: 650,
        playerSpeed: 1.5,
        npcBaseSpeed: 0.9,
        slipperSpeed: 10,
        pickupDistanceOffset: 10,
        boundaryY: 550, // equivalent to CANVAS_HEIGHT - 100
        chaseNearCanDistance: 250, // Player must be this close to the can to trigger/cancel chase BEFORE throwing
        shakeDuration: 10,
        particleLifetime: 120, // Increased frames for particle to live and fade
        particleSpeed: 1.5,   // Increased pixels per frame upwards
        joystickMaxDist: 30, // Max distance joystick thumb can move from center
        joystickDeadzone: 5, // Minimum distance joystick must be moved to register as active
    };

    // Game state
    const state = {
        score: 0,
        isGameOver: false,
        isPaused: false, // Default to not paused
        messageTimer: 0,
        canWasHitThisRound: false,
        playerCarriedSlipperBack: false,
        shakeTimer: 0,
        shakeX: 0,
        shakeY: 0,
        scoreParticles: [], // Array to hold score particle objects
        joystickActive: false,
        joystickStartX: 0,
        joystickStartY: 0,
        joystickCurrentX: 0,
        joystickCurrentY: 0,
    };

    // DOM
    const gameWrapper = document.querySelector('.game-wrap'); // Get the game wrapper
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreValueElement = document.getElementById('scoreValue');
    const messageBox = document.getElementById('messageBox');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    const mobileControlsContainer = document.getElementById('mobileControlsContainer'); // Get the container
    const joystickArea = document.getElementById('joystickArea');
    const joystickThumb = document.getElementById('joystickThumb');
    const mobileThrowBtn = document.getElementById('mobile-throw-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');


    // Resize canvas
    canvas.width = config.canvasWidth;
    canvas.height = config.canvasHeight;

    // =====================
    // Sprites & Entities
    // =====================
    const backgroundMap = new Image();
    backgroundMap.src = 'place.png'; // This is for the in-game background

    // New image for the start screen background
    const startBackground = new Image();
    startBackground.src = 'start.png'; // Assuming 'start.png' is in the same directory

    // Set the start overlay background image when it loads
    startBackground.onload = () => {
        startOverlay.style.backgroundImage = `url('${startBackground.src}')`;
    };


    const playerSprite = new Image(); playerSprite.src = 'avatar.png';
    const playerColumns = 3, playerRows = 3;
    let playerFrameW = 0, playerFrameH = 0;

    const npcSprite = new Image(); npcSprite.src = 'npc.png';
    const npcColumns = 4, npcRows = 4;
    let npcFrameW = 0, npcFrameH = 0;

    // New Image objects for can and slipper
    const canImage = new Image(); canImage.src = 'can.png';
    const slipperImage = new Image(); slipperImage.src = 'slipper.png';


    const player = {
        x: canvas.width / 2,
        y: canvas.height - 25,
        width: 55,
        height: 55,
        dir: 0, // 0 down,1 up,2 left,3 right
        moving: false,
        currFrame: 1,
        frameCounter:0,
    };

    const npc = {
        x: canvas.width / 2 + 50,
        y: 190,
        width: 85,
        height: 85,
        speed: config.npcBaseSpeed,
        state: 'idle', // 'idle', 'movingToCan', 'returningCan', 'guardingSlipper', 'chasing', 'returningToOrigin'
        carryingCan: false,
        originalX: canvas.width / 2 + 50,
        originalY: 190,
        guardRadius: 40, 
        patrolRadius: 150, 
        chaseReturnBuffer: 50, 
        patrolTargetX: null,
        patrolTargetY: null,
        currFrame:0,
        frameCounter:0,
        dir: 0, // 0 down,1 left,2 right,3 up
    };
    
    // You can adjust the can's starting position here.
    const can = {
        x: canvas.width/2,
        y: 270,
        size: 50,
        image: canImage,
        isHit: false,
        vx:0, vy:0,
        rotation:0,
        rotationSpeed:0,
        mass: 1.5,
        originalX: canvas.width/2,
        originalY: 270
    };

    const slipper = {
        x: player.x + 10,
        y: player.y - 15,
        size: 40,
        image: slipperImage,
        isHeld: true,
        speed: config.slipperSpeed,
        vx:0, vy:0,
        justThrown:false,
        throwCooldown:0,
        rotation: 0,
        rotationSpeed: 0,
    };

    const keys = { up:false, down:false, left:false, right:false, space:false };

    // =====================
    // Helpers
    // =====================
    function showMessage(html, duration=180){
        messageBox.innerHTML = html;
        messageBox.style.display = 'block';
        state.messageTimer = duration; // Only set timer if not game over
    }
    function hideMessage(){ messageBox.style.display = 'none'; }

    function startShake(duration=config.shakeDuration){ state.shakeTimer = duration; }

    function applyShake(){
        if(state.shakeTimer>0){
            state.shakeTimer--;
            // small random shake
            state.shakeX = (Math.random()-0.5)*6;
            state.shakeY = (Math.random()-0.5)*6;
        } else { state.shakeX=0; state.shakeY=0; }
    }

    // =====================
    // Initialization after sprite load
    // =====================
    playerSprite.onload = ()=>{ playerFrameW = playerSprite.width / playerColumns; playerFrameH = playerSprite.height / playerRows; };
    npcSprite.onload = ()=>{ npcFrameW = npcSprite.width / npcColumns; npcFrameH = npcSprite.height / npcRows; };


    // =====================
    // Input (Keyboard & Mobile Touch)
    // =====================
    window.addEventListener('keydown', (e)=>{
        if(state.isGameOver || state.isPaused) return; // Prevent input if game over or paused
        const key = e.key.toLowerCase();
        if(key==='w' || key==='arrowup') { keys.up=true; }
        else if(key==='s' || key==='arrowdown'){ keys.down=true; }
        else if(key==='a' || key==='arrowleft'){ keys.left=true; }
        else if(key==='d' || key==='arrowright'){ keys.right=true; }
        else if(key===' '){
            if(!keys.space && slipper.isHeld && !slipper.justThrown && player.y >= config.boundaryY){
                keys.space = true; throwSlipperTowardCan();
            }
        } else if(key==='p'){
            togglePause();
        } else if(key==='r'){
            resetGame(); // 'R' now goes to start screen
        }
    });

    window.addEventListener('keyup',(e)=>{
        if(state.isGameOver || state.isPaused) return; // Prevent input if game over or paused
        const key = e.key.toLowerCase();
        if(key==='w' || key==='arrowup') keys.up=false;
        else if(key==='s' || key==='arrowdown') keys.down=false;
        else if(key==='a' || key==='arrowleft') keys.left=false;
        else if(key==='d' || key==='arrowright') keys.right=false;
        else if(key===' ') { keys.space=false; }
        // player.moving and player.dir are now handled by updatePlayerStateFromKeys
    });

    // Mobile Joystick Logic
    joystickArea.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent default touch behavior (scrolling, zooming)
        state.joystickActive = true;
        const rect = joystickArea.getBoundingClientRect();
        state.joystickStartX = rect.left + rect.width / 2;
        state.joystickStartY = rect.top + rect.height / 2;
        handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
    });

    joystickArea.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (state.joystickActive) {
            handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
        }
    });

    joystickArea.addEventListener('touchend', () => {
        state.joystickActive = false;
        state.joystickCurrentX = 0;
        state.joystickCurrentY = 0;
        joystickThumb.style.transform = 'translate(-50%, -50%)'; // Reset thumb position
        // Explicitly reset all keys when joystick is released
        keys.up = false;
        keys.down = false;
        keys.left = false;
        keys.right = false;
    });

    function handleJoystickMove(touchX, touchY) {
        let dx = touchX - state.joystickStartX;
        let dy = touchY - state.joystickStartY;
        const distance = Math.hypot(dx, dy);

        if (distance > config.joystickMaxDist) {
            dx = (dx / distance) * config.joystickMaxDist;
            dy = (dy / distance) * config.joystickMaxDist;
        }

        state.joystickCurrentX = dx;
        state.joystickCurrentY = dy;

        // Move the joystick thumb visually
        joystickThumb.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;

        // Translate joystick movement to keys state based on direction and deadzone
        if (distance > config.joystickDeadzone) {
            // Only set keys if outside deadzone
            keys.up = dy < -config.joystickDeadzone;
            keys.down = dy > config.joystickDeadzone;
            keys.left = dx < -config.joystickDeadzone;
            keys.right = dx > config.joystickDeadzone;
        } else {
            // Reset keys if inside deadzone (no significant movement)
            keys.up = false;
            keys.down = false;
            keys.left = false;
            keys.right = false;
        }
    }


    // Mobile Throw Button Logic
    mobileThrowBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!state.isPaused && !state.isGameOver && slipper.isHeld && !slipper.justThrown && player.y >= config.boundaryY) {
            throwSlipperTowardCan();
        }
    });

    // Start button
    startBtn.addEventListener('click', ()=>{
        startOverlay.style.display='none';
        // Only show mobile controls if on a mobile device (or small screen based on media query)
        // Check if the current window matches the mobile breakpoint for display
        if (window.matchMedia("(max-width: 768px)").matches) {
            mobileControlsContainer.style.display = 'block';
        }
        startLoop();
    });

    // Fullscreen button
    fullscreenBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            if (gameWrapper.requestFullscreen) {
                gameWrapper.requestFullscreen();
            } else if (gameWrapper.mozRequestFullScreen) { /* Firefox */
                gameWrapper.mozRequestFullScreen();
            } else if (gameWrapper.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                gameWrapper.webkitRequestFullscreen();
            } else if (gameWrapper.msRequestFullscreen) { /* IE/Edge */
                gameWrapper.msRequestFullscreen();
            }
        }
    });


    // =====================
    // Actions
    // =====================
    function throwSlipperTowardCan(){
        if(state.isPaused || state.isGameOver) return;
        if(!slipper.isHeld) return;
        slipper.isHeld = false; slipper.justThrown = true; slipper.throwCooldown = 10;
        const dx = can.x - player.x; const dy = can.y - player.y; const distance = Math.hypot(dx,dy)||1;
        slipper.vx = (dx/distance)*slipper.speed; slipper.vy = (dy/distance)*slipper.speed;
        slipper.x += slipper.vx * 0.5; slipper.y += slipper.vy * 0.5;
        // Add a random spin to the slipper
        slipper.rotationSpeed = (Math.random() - 0.5) * 0.5;
    }

    function togglePause(){ state.isPaused = !state.isPaused; if(state.isPaused) showMessage('Paused'); else hideMessage(); }

    // =====================
    // Update split into smaller functions
    // =====================
    // NEW: Function to update player state (moving, direction, animation) based on keys
    function updatePlayerStateFromKeys() {
        player.moving = keys.up || keys.down || keys.left || keys.right;

        if (player.moving) {
            // Determine primary direction for animation
            if (keys.left) player.dir = 2;
            else if (keys.right) player.dir = 3;
            else if (keys.up) player.dir = 1;
            else if (keys.down) player.dir = 0;

            // Update animation frame
            player.frameCounter++;
            if (player.frameCounter % 10 === 0) {
                player.currFrame = (player.currFrame + 1) % playerColumns;
            }
        } else {
            player.currFrame = 1; // Default frame when idle
            player.frameCounter = 0; // Reset frame counter when idle
        }
    }

    function updatePlayerMovement(){
        if(player.moving){ // player.moving is now set by updatePlayerStateFromKeys
            let vx=0, vy=0;
            if(keys.up) vy -=1;
            if(keys.down) vy +=1;
            if(keys.left) vx -=1;
            if(keys.right) vx +=1;
            const mag = Math.hypot(vx,vy);
            if(mag>0){ player.x += (vx/mag)*config.playerSpeed; player.y += (vy/mag)*config.playerSpeed; }
        }
        // keep inside
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
        player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
    }

    function updateSlipper(){
        if(slipper.throwCooldown>0) slipper.throwCooldown--;
        else slipper.justThrown = false;

        if(slipper.isHeld){ slipper.x = player.x + 10; slipper.y = player.y - 15; }
        else {
            slipper.x += slipper.vx; slipper.y += slipper.vy;
            slipper.vx *= 0.98; slipper.vy *= 0.98;
            slipper.rotation += slipper.rotationSpeed;
            slipper.rotationSpeed *= 0.98;

            // wall bounce
            if(slipper.x - slipper.size/2 < 0 || slipper.x + slipper.size/2 > canvas.width){ slipper.vx *= -0.7; slipper.x = Math.max(slipper.size/2, Math.min(canvas.width - slipper.size/2, slipper.x)); }
            if(slipper.y - slipper.size/2 < 0 || slipper.y + slipper.size/2 > canvas.height){ slipper.vy *= -0.7; slipper.y = Math.max(slipper.size/2, Math.min(canvas.height - slipper.size/2, slipper.y)); }

            // collision with can
            const dx = slipper.x - can.x; const dy = slipper.y - can.y; const dist = Math.hypot(dx,dy);
            const minDist = slipper.size/2 + can.size/2;
            if(dist < minDist && !can.isHit){
                can.isHit = true; state.canWasHitThisRound = true; startShake(8);
                const nx = dx/dist; const ny = dy/dist;
                const relVx = slipper.vx - can.vx; const relVy = slipper.vy - can.vy;
                const impulse = 2 * (relVx*nx + relVy*ny) / (1/slipper.size + 1/can.mass);
                slipper.vx -= impulse * nx / slipper.size; 
                slipper.vy -= impulse * ny / slipper.size; 
                can.vx += impulse * nx / can.mass; can.vy += impulse * ny / can.mass;
                const overlap = minDist - dist + 1; slipper.x += nx*overlap; slipper.y += ny*overlap;
                npc.state = 'movingToCan'; // NPC starts moving towards the can's current position
            }
            if(Math.abs(slipper.vx) < 0.2 && Math.abs(slipper.vy) < 0.2){ slipper.vx=0; slipper.vy=0; }
        }

        // pickup by player
        if(!slipper.isHeld && !slipper.justThrown){
            const dxp = player.x - slipper.x; const dyp = player.y - slipper.y; const d = Math.hypot(dxp,dyp);
            const pickupRadius = player.width/2 + slipper.size/2 + config.pickupDistanceOffset;
            if(d < pickupRadius){
                slipper.isHeld = true; slipper.vx=0; slipper.vy=0;
                slipper.rotation = 0; slipper.rotationSpeed = 0;
                if(state.canWasHitThisRound) state.playerCarriedSlipperBack = true;
            }
        }
    }

    function updateCanPhysics(){
        if(can.isHit){
            can.x += can.vx; can.y += can.vy; can.rotation += can.rotationSpeed;
            can.vx *= 0.95; can.vy *= 0.95; can.rotationSpeed *= 0.95;
            if(can.x - can.size/2 < 0 || can.x + can.size/2 > canvas.width){ can.vx *= -0.5; can.x = Math.max(can.size/2, Math.min(canvas.width - can.size/2, can.x)); }
            if(can.y - can.size/2 < 0 || can.y + can.size/2 > canvas.height){ can.vy *= -0.5; can.y = Math.max(can.size/2, Math.min(canvas.height - can.size/2, can.y)); }
            if(Math.abs(can.vx)<0.1 && Math.abs(can.vy)<0.1 && Math.abs(can.rotationSpeed)<0.01){ can.vx=0; can.vy=0; can.rotationSpeed=0; }
        }

        // scoring: when player returns slipper to safe zone after hitting can
        if(state.playerCarriedSlipperBack && player.y >= config.boundaryY){
            state.score++; 
            scoreValueElement.textContent = state.score; 
            state.canWasHitThisRound = false; 
            state.playerCarriedSlipperBack = false;
            
            // Add a score particle effect
            state.scoreParticles.push({
                x: player.x,
                y: player.y,
                alpha: 1.0,
                life: config.particleLifetime
            });

            // Decrease patrol radius and chase return buffer by 5 for every 2 points scored
            if (state.score % 2 === 0) {
                npc.patrolRadius = Math.max(20, npc.patrolRadius - 5); // Minimum 20px
                npc.chaseReturnBuffer = Math.max(10, npc.chaseReturnBuffer - 5); // Minimum 10px
            }

            // reset can & npc
            can.x = can.originalX; can.y = can.originalY; can.isHit=false; can.vx=0; can.vy=0; can.rotation=0; can.rotationSpeed=0;
            npc.x = npc.originalX; npc.y = npc.originalY; npc.state='idle'; npc.carryingCan=false; npc.speed = config.npcBaseSpeed + Math.floor(state.score/3)*0.3;
        }
    }

    function updateNPCBehavior(){
        let npcMoving=false;
        const distPlayerToCan = Math.hypot(player.x - can.x, player.y - can.y);
        const distPlayerToSlipper = Math.hypot(player.x - slipper.x, player.y - slipper.y);

        // --- NPC Chase Activation Logic ---
        // Trigger chase if player gets too close to the can BEFORE throwing (slipper is held, can is not hit)
        if (slipper.isHeld && !can.isHit && distPlayerToCan < config.chaseNearCanDistance && npc.state !== 'chasing') {
            npc.state = 'chasing';
            npc.patrolTargetX = null; // Reset patrol target
            npc.patrolTargetY = null;
        }
        // Trigger chase if player approaches the slipper AFTER throwing (slipper is not held, NPC is guarding slipper)
        else if (!slipper.isHeld && npc.state === 'guardingSlipper' && distPlayerToSlipper < npc.guardRadius) {
            npc.state = 'chasing';
            npc.patrolTargetX = null; // Reset patrol target
            npc.patrolTargetY = null;
        }

        // Update NPC direction to face player when idle
        if(npc.state === 'idle') {
            const dx = player.x - npc.x;
            const dy = player.y - npc.y;
            npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);
        }
        
        switch(npc.state){
            case 'movingToCan':
                npcMoving = true;
                {
                    const dx = can.x - npc.x; // Target is the can's current (hit) position
                    const dy = can.y - npc.y;
                    const dist = Math.hypot(dx,dy)||1;
                    npc.dir = Math.abs(dx)>Math.abs(dy) ? (dx>0?2:1) : (dy>0?0:3);
                    if(dist > 5){ // Move until close to pick up
                        npc.x += (dx/dist)*npc.speed;
                        npc.y += (dy/dist)*npc.speed;
                    } else {
                        npc.carryingCan = true; // NPC picks up the can
                        npc.state = 'returningCan'; // Transition to returning state
                    }
                }
                break;
            case 'returningCan':
                npcMoving = true;
                {
                    const dx = can.originalX - npc.x; // NPC targets the can's ORIGINAL spot
                    const dy = can.originalY - npc.y; // NPC targets the can's ORIGINAL spot
                    const dist = Math.hypot(dx, dy) || 1; 

                    npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);

                    // If NPC is very close to the original position, snap the can and transition state
                    if(dist < 5){ 
                        can.x = can.originalX; // Snap can to the exact spot
                        can.y = can.originalY;
                        can.isHit = false;
                        can.rotation = 0;
                        npc.carryingCan = false;
                        npc.state = 'guardingSlipper'; // Immediately transition to guarding
                    } else {
                        npc.x += (dx/dist)*npc.speed;
                        npc.y += (dy/dist)*npc.speed;
                        can.x = npc.x; // Can visually follows NPC during movement
                        can.y = npc.y;
                    }
                }
                break;
            case 'guardingSlipper':
                npcMoving = true;
                if(npc.patrolTargetX===null || npc.patrolTargetY===null){
                    const angle = Math.random()*Math.PI*2; 
                    // Use the dynamically adjusted patrolRadius
                    const distance = Math.random()*npc.patrolRadius;
                    npc.patrolTargetX = slipper.x + Math.cos(angle)*distance; 
                    npc.patrolTargetY = slipper.y + Math.sin(angle)*distance;
                }
                {
                    const dx = npc.patrolTargetX - npc.x; const dy = npc.patrolTargetY - npc.y; const dist = Math.hypot(dx,dy)||1;
                    npc.dir = Math.abs(dx)>Math.abs(dy) ? (dx>0?2:1) : (dy>0?0:3);
                    if(dist > 5){ npc.x += (dx/dist)*npc.speed; npc.y += (dy/dist)*npc.speed; }
                    else { npc.patrolTargetX=null; npc.patrolTargetY=null; }
                }
                break; // No need for chase activation here, handled above
            case 'chasing':
                npcMoving = true;
                {
                    const dx = player.x - npc.x; const dy = player.y - npc.y; const dist = Math.hypot(dx,dy)||1;
                    npc.dir = Math.abs(dx)>Math.abs(dy) ? (dx>0?2:1) : (dy>0?0:3);
                    if(dist > npc.width/2) { npc.x += (dx/dist)*npc.speed; npc.y += (dy/dist)*npc.speed; }
                }
                // Collision detection (catch: Game Over)
                const tolerance = 43; // pixels
                const currentDistToPlayer = Math.hypot(player.x - npc.x, player.y - npc.y);
                
                if (currentDistToPlayer < tolerance) {
                    state.isGameOver = true; // Set game over state
                    startShake(); // Activate screen shake for impact
                    // Updated message for game over
                    showMessage(`<span style="color:red; font-weight:bold; font-size: 2em; font-family: 'Press Start 2P', cursive;">Game Over!</span><br><span style="color:yellow; font-size: 1.5em; font-family: 'Press Start 2P', cursive;">${state.score}!!</span><br><br><button id="playAgainBtn">Retry</button>`, 0);
                    document.getElementById('playAgainBtn').addEventListener('click', resetGame); // Attach listener to retry button
                }
                
                // --- NPC Chase Cancellation Logic ---
                // Scenario 1: Player has the slipper (before throwing) and moves away from can area
                if (slipper.isHeld && !can.isHit) {
                    // Cancel if player moves away from can by 250px or more (using the same chaseNearCanDistance)
                    if (distPlayerToCan >= config.chaseNearCanDistance) { // Now uses 250px
                        npc.state = 'returningToOrigin'; // Go back to origin
                        npc.patrolTargetX = null;
                        npc.patrolTargetY = null;
                    }
                }
                // Scenario 2: Slipper is not held (after throwing) and player leads NPC far from slipper
                else if (!slipper.isHeld) {
                    // Cancel if player leads NPC far from slipper
                    if (distPlayerToSlipper > npc.guardRadius + npc.chaseReturnBuffer) {
                        npc.state = 'guardingSlipper'; 
                        npc.patrolTargetX = null; 
                        npc.patrolTargetY = null; 
                    }
                }
                break;
            case 'returningToOrigin': // NPC moves back to its original position
                npcMoving = true;
                {
                    const dx = npc.originalX - npc.x;
                    const dy = npc.originalY - npc.y;
                    const dist = Math.hypot(dx, dy) || 1;

                    npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);

                    if (dist > 5) { // Move until close to origin
                        npc.x += (dx / dist) * npc.speed;
                        npc.y += (dy / dist) * npc.speed;
                    } else {
                        // Snap to original position and go idle
                        npc.x = npc.originalX;
                        npc.y = npc.originalY;
                        npc.state = 'idle';
                        npc.patrolTargetX = null;
                        npc.patrolTargetY = null;
                    }
                }
                break;
        }

        // npc animation
        if(npcMoving){ npc.frameCounter++; if(npc.frameCounter%15===0) npc.currFrame = (npc.currFrame+1) % npcColumns; }
        else npc.currFrame = 0;
    }

    function updateAnimations(){
        // Update score particles
        for (let i = state.scoreParticles.length - 1; i >= 0; i--) {
            const particle = state.scoreParticles[i];
            particle.y -= config.particleSpeed; // Move upwards
            particle.alpha -= 1 / config.particleLifetime; // Fade out

            if (particle.alpha <= 0) {
                state.scoreParticles.splice(i, 1); // Remove if fully faded
            }
        }
    }

    function updateAll(){
        if(state.isPaused || state.isGameOver) return; // Only run updates if not paused or game over
        if(state.messageTimer>0){ state.messageTimer--; if(state.messageTimer===0) hideMessage(); }

        applyShake();

        updatePlayerStateFromKeys(); // NEW: Update player moving/dir/animation based on keys
        updatePlayerMovement();
        updateSlipper();
        updateCanPhysics();
        updateNPCBehavior();
        updateAnimations();
    }

    // =====================
    // Drawing
    // =====================
    function drawBackground(){
        if (backgroundMap.complete) {
            ctx.drawImage(backgroundMap, 0, 0, canvas.width, canvas.height);
        } else {
            // Fallback color if the image hasn't loaded yet
            ctx.fillStyle='forestgreen';
            ctx.fillRect(0,0,canvas.width,canvas.height);
        }
    }
    function drawBoundary(){ ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,config.boundaryY); ctx.lineTo(config.canvasWidth, config.boundaryY); ctx.stroke(); }
    
    function drawCan(){
        // Only draw the can independently if the NPC is not currently carrying it
        if(!npc.carryingCan){
            if (can.image.complete) {
                ctx.save();
                ctx.translate(can.x, can.y);
                ctx.rotate(can.rotation);
                // Draw the image centered
                ctx.drawImage(can.image, -can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            } else {
                // Fallback drawing if image not loaded
                ctx.save(); ctx.translate(can.x, can.y); ctx.rotate(can.rotation);
                ctx.fillStyle = 'gray'; ctx.fillRect(-can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            }
        }
    }

    function drawSlipper(){
        if (slipper.image.complete) {
            ctx.save();
            ctx.translate(slipper.x, slipper.y);
            ctx.rotate(slipper.rotation);
            // Draw the image centered
            ctx.drawImage(slipper.image, -slipper.size/2, -slipper.size/2, slipper.size, slipper.size);
            ctx.restore();
        } else {
            // Fallback drawing if image not loaded
            ctx.save(); ctx.translate(slipper.x, slipper.y); ctx.rotate(slipper.rotation);
            ctx.fillStyle = 'brown'; ctx.fillRect(-slipper.size/2, -slipper.size/2, slipper.size, slipper.size);
            ctx.restore();
        }
    }

    function drawNPC(){
        if(!npcSprite.complete) return;
        const scale=1;
        const sw = npcFrameW, sh = npcFrameH;
        const dw = npc.width, dh = npc.height;
        ctx.save();
        ctx.drawImage(npcSprite, npc.currFrame*npcFrameW, (npc.dir||0)*npcFrameH, npcFrameW, npcFrameH, npc.x - dw/2, npc.y - dh/2, dw, dh);
        
        // Draw the can only if NPC is carrying it
        if(npc.carryingCan){
            if (can.image.complete) {
                ctx.save();
                ctx.translate(npc.x, npc.y - 30); // Position above NPC head
                ctx.rotate(can.rotation);
                ctx.drawImage(can.image, -can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            } else {
                // Fallback if can image not loaded
                ctx.save(); ctx.translate(npc.x, npc.y-30); ctx.rotate(can.rotation);
                ctx.fillStyle = 'gray'; ctx.fillRect(-can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            }
        }
        ctx.restore();
    }

    function drawPlayer(){
        if(!playerSprite.complete) return;
        const row = (player.dir===2||player.dir===3)?2:player.dir;
        const flip = player.dir===3;
        const frame = player.moving ? player.currFrame : 1;
        const sx = Math.floor(frame*playerFrameW);
        const sy = Math.floor(row*playerFrameH);
        const sw = Math.floor(playerFrameW-1);
        const sh = Math.floor(playerFrameH);
        ctx.save();
        if(flip){
            ctx.scale(-1,1);
            ctx.drawImage(playerSprite, sx, sy, sw, sh, -player.x - player.width/2, player.y - player.height/2, player.width, player.height);
        } else {
            ctx.drawImage(playerSprite, sx, sy, sw, sh, player.x - player.width/2, player.y - player.height/2, player.width, player.height);
        }
        ctx.restore();
    }

    function drawScoreParticles(){
        ctx.save();
        ctx.font = 'bold 36px "Press Start 2P"'; // Apply pixel font to particles
        ctx.textAlign = 'center';
        ctx.shadowBlur = 15; // Increased glow effect
        ctx.shadowOffsetX = 0; // Ensure shadow is centered
        ctx.shadowOffsetY = 0; // Ensure shadow is centered

        state.scoreParticles.forEach(particle => {
            ctx.globalAlpha = particle.alpha;
            // Changed color to yellow
            ctx.fillStyle = `rgba(255, 255, 0, ${particle.alpha})`; // Yellow color for +1
            ctx.shadowColor = `rgba(255, 255, 0, ${particle.alpha})`; // Yellow glow
            ctx.fillText('+1', particle.x, particle.y);
        });
        ctx.restore();
    }


    function drawAll(){
        // apply screen shake offset
        ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.translate(state.shakeX, state.shakeY);
        drawBackground(); drawBoundary(); drawNPC(); drawCan(); drawSlipper(); drawPlayer();
        drawScoreParticles(); // Draw particles after everything else
        ctx.restore();
    }

    // =====================
    // Game loop
    // =====================
    let loopId = null;
    function loop(){ updateAll(); drawAll(); loopId = requestAnimationFrame(loop); }
    function startLoop(){
        if(loopId) cancelAnimationFrame(loopId);
        loop();
    }

    function resetGame(){
        state.isGameOver=false;
        state.isPaused=true; // Game is paused on the start screen
        state.score=0;
        scoreValueElement.textContent = 0;
        hideMessage(); // Hide game over message if visible

        // Reset game entities (player, slipper, can, npc) to their initial positions/states
        player.x = canvas.width/2; player.y = canvas.height - 25; player.moving=false; player.currFrame=1;
        slipper.isHeld = true; slipper.vx=0; slipper.vy=0; slipper.x = player.x + 10; slipper.y = player.y - 15; slipper.justThrown=false; slipper.throwCooldown=0;
        slipper.rotation = 0; slipper.rotationSpeed = 0;
        can.x = can.originalX; can.y = can.originalY; can.isHit=false; can.vx=0; can.vy=0; can.rotation=0; can.rotationSpeed=0;
        npc.x = npc.originalX; npc.y = npc.originalY; npc.state='idle'; npc.carryingCan=false;
        npc.speed = config.npcBaseSpeed;
        npc.patrolRadius = 50;
        npc.chaseReturnBuffer = 50;
        state.canWasHitThisRound=false; state.playerCarriedSlipperBack=false;
        state.scoreParticles = [];

        // Make NPC face player on reset (optional, but good for consistency)
        const dx = player.x - npc.x;
        const dy = player.y - npc.y;
        npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);

        // Show the start overlay and hide mobile controls
        startOverlay.style.display='flex'; // Show start overlay
        mobileControlsContainer.style.display = 'none'; // Hide mobile controls

        // Stop the game loop (if running)
        if(loopId) cancelAnimationFrame(loopId);
        loopId = null; // Ensure loopId is nullified
    }

    // expose reset to global for console convenience
    window.resetGame = resetGame;

    // Start API for outside (optional)
    window.startGame = ()=>{ startOverlay.style.display='none'; startLoop(); };

    const helpIcon = document.getElementById('help-icon');
    const helpOverlay = document.getElementById('help-overlay');
    const closeHelp = document.getElementById('close-help');

    // Updated Help Icon Event Listeners
    helpIcon.addEventListener('click', () => {
        state.isPaused = true; // Pause the game when help is displayed
        helpOverlay.style.display = 'flex';
    });
    closeHelp.addEventListener('click', () => {
        state.isPaused = false; // Unpause the game when help is closed
        helpOverlay.style.display = 'none';
    });

    // Initial setup when the page loads
    window.addEventListener('load', () => {
        // Ensure game starts paused with the start overlay visible and controls hidden
        resetGame(); // This will set isPaused=true, show startOverlay, hide mobileControls
    });

    // Utility: attach play again button listener if present after message show
    const observer = new MutationObserver(()=>{ const btn = document.getElementById('playAgainBtn'); if(btn) btn.addEventListener('click', resetGame); });
    observer.observe(messageBox, {childList:true, subtree:true});
</script>
</body>
</html>
