<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Bato Lata</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        :root{
            --bg:#2c3e50;
            --panel:#34495e;
            --accent:#0f3460;
            --glass:rgba(0,0,0,0.45);
        }
        html,body{
            height:100%;
            margin:0;
            font-family: 'Inter', sans-serif;
            background:var(--bg);
            color:#e0e0e0;
            display:flex;
            align-items:center;
            justify-content:center;
            overflow: hidden;
        }
        
        #help-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.43 12.92 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.35 1.7-.92 2.25z"/></svg>') no-repeat center/cover;
            cursor: pointer;
            filter: drop-shadow(0px 0px 3px rgba(0,0,0,0.5));
            z-index: 150;
        }
        #help-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            z-index: 200;
        }
        #help-content {
            max-width: 500px;
            text-align: center;
            background: var(--panel);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }
        #help-overlay button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            background: #3498db;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #help-overlay button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        .game-wrap{
            position:relative;
            display:flex;
            flex-direction:column;
            align-items:center;
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 650px;
        }
        h1{
            margin:12px 0 0 0;
            font-weight:700;
            text-shadow:2px 2px 4px rgba(0,0,0,0.4);
        }
        canvas{
            display:block;
            border:4px solid var(--accent);
            border-radius:12px;
            box-shadow:0 8px 24px rgba(0,0,0,0.6);
            margin:16px 0;
            width: 100%;
            height: auto;
            flex-grow: 1;
        }
        .score-board{
            position:absolute;
            top:14px;
            left:14px;
            font-size:1.1rem;
            font-weight:700;
            background:var(--glass);
            padding:8px 12px;
            border-radius:8px;
            backdrop-filter: blur(4px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            z-index: 10;
        }
        .message-box{
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%);
            background:var(--panel);
            color:#fff;
            padding:24px 28px;
            border-radius:12px;
            border: 3px solid white;
            box-shadow:0 6px 20px rgba(0,0,0,0.5);
            text-align:center;
            font-size:1.5rem;
            display:none;
            z-index:100;
        }
        .message-box button{
            margin-top:12px;
            padding:10px 16px;
            border-radius:10px;
            border:none;
            background:#3498db;
            color:#fff;
            cursor:pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .message-box button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        .instructions{
            position:absolute;
            right:14px;
            top:14px;
            background:var(--glass);
            padding:10px 12px;border-radius:8px;font-size:0.9rem;
        }
        .overlay-start{
            position:absolute;
            inset:0;
            display:flex;
            flex-direction: column;
            align-items:center;
            justify-content:center;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index:120;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
        }
        .overlay-card{
            background:rgba(0,0,0,0.6);
            padding:20px 30px;
            border-radius:12px;
            text-align:center;
            box-shadow:0 8px 30px rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            height: 100%;
            width: 100%;
            box-sizing: border-box;
            padding-bottom: 50px;
        }
        .overlay-card h2{
            font-family: 'Press Start 2P', cursive;
            font-size: 2.2em;
            margin-bottom: 8px;
            color: #ffeb3b;
            text-shadow: 0 0 8px rgba(255,255,0,0.8);
        }
        .overlay-card p{
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em;
            line-height: 1.6;
            max-width: 80%;
            margin: 10px auto 30px auto;
        }
        .overlay-card button{
            margin-top:12px;
            padding:10px 20px;
            border-radius:10px;
            border:none;
            background:#2ecc71;
            color:#fff;
            cursor:pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.1em;
        }
        .overlay-card button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        /* Leaderboard Styles */
        .leaderboard-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.8);
            width: 80%;
            max-width: 400px;
            z-index: 200;
            display: none;
        }
        .leaderboard-container h3 {
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            margin-bottom: 15px;
            color: #ffeb3b;
            text-shadow: 0 0 8px rgba(255,255,0,0.8);
        }
        .leaderboard-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 5px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
        }
        .leaderboard-item:nth-child(-n+3) {
            color: gold;
            font-weight: bold;
        }
        .leaderboard-item:nth-child(1) {
            font-size: 0.8em;
        }
        .leaderboard-item:nth-child(2) {
            font-size: 0.75em;
        }
        .leaderboard-item:nth-child(3) {
            font-size: 0.7em;
        }
        .leaderboard-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .leaderboard-form input {
            padding: 10px;
            border-radius: 5px;
            border: none;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            text-align: center;
        }
        .leaderboard-form button {
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: #2ecc71;
            color: white;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
        }
        .leaderboard-buttons {
            display: flex;
            gap: 10px;
        }
        .leaderboard-buttons button {
            flex: 1;
        }
        .leaderboard-buttons button.cancel {
            background: #e74c3c;
        }

        /* Mobile Controls */
        .mobile-controls-container {
            display: none;
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            height: 120px;
            z-index: 150;
        }
        .joystick-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100px;
            height: 100px;
            background: rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
        }
        .joystick-thumb {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
        }
        #mobile-throw-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 80px;
            height: 80px;
            background: rgba(128, 128, 128, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-image: url('slipper.png');
            background-size: 60%;
            background-position: center;
            background-repeat: no-repeat;
            font-size: 0;
            color: transparent;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            user-select: none;
            cursor: pointer;
            transition: background 0.1s ease;
        }
        #mobile-throw-btn:active {
            background: rgba(128, 128, 128, 0.6);
            transform: scale(0.95);
        }
        #fullscreen-btn {
            display: none;
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(52, 152, 219, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            font-size: 0.9em;
            cursor: pointer;
            z-index: 150;
            transition: background 0.2s ease;
        }
        #fullscreen-btn:hover {
            background: rgba(52, 152, 219, 1);
        }

        /* Media queries for mobile display */
        @media (max-width: 768px) {
            .game-wrap {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
                margin: 0;
            }
            canvas {
                border-radius: 0;
            }
            .score-board {
                font-size: 1.2rem;
                padding: 10px 15px;
            }
            #help-icon {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
            }
            #fullscreen-btn {
                display: block;
            }
            .overlay-start {
                padding: 0;
            }
            .overlay-card {
                padding-bottom: 30px;
            }
            .message-box {
                font-size: 1.2rem;
                padding: 20px;
            }
            .leaderboard-container {
                width: 90%;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="help-icon"></div>
    <div id="fullscreen-btn">Go Fullscreen</div>

    <div id="help-overlay">
      <div id="help-content">
        <h2>How to Play</h2>
        <p>Move with WASD or Arrow Keys.<br>
            Press SPACE to throw the slipper.<br>
            Knock down the can to score points.<br>
            Avoid getting caught by the NPC.<br>
            Press P to pause and R to restart.<br>
            Mobile: Use on-screen joystick and throw button.</p>
        <button id="close-help">Close</button>
      </div>
    </div>
    
    <div class="game-wrap">
        <div class="score-board">Score: <span id="scoreValue">0</span></div>
        <canvas id="gameCanvas"></canvas>

        <div id="messageBox" class="message-box"></div>

        <div id="startOverlay" class="overlay-start">
            <div class="overlay-card">
                <h2>Bato Lata</h2>
                <p>Move with WASD or Arrow keys. Press SPACE to throw the slipper toward the can. Bring back the slipper after hitting the can to score. Don't let the guard catch you!</p>
                <button id="startBtn">Start Game</button>
                <button id="leaderboardBtn">View Leaderboard</button>
            </div>
        </div>

        <div class="mobile-controls-container" id="mobileControlsContainer">
            <div class="joystick-area" id="joystickArea">
                <div class="joystick-thumb" id="joystickThumb"></div>
            </div>
            <div id="mobile-throw-btn"></div>
        </div>
    </div>

    <!-- Leaderboard Container -->
    <div id="leaderboardContainer" class="leaderboard-container">
        <h3>Global Leaderboard</h3>
        <div id="leaderboardList" class="leaderboard-list">
            <!-- Leaderboard items will be populated here -->
        </div>
        <div id="leaderboardForm" class="leaderboard-form" style="display: none;">
            <p>Congratulations! You made it to the top 10!</p>
            <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
            <div class="leaderboard-buttons">
                <button id="submitScoreBtn">Submit Score</button>
                <button id="cancelSubmitBtn" class="cancel">Cancel</button>
            </div>
        </div>
        <div class="leaderboard-buttons">
            <button id="closeLeaderboardBtn">Close</button>
        </div>
    </div>

    <script>
    // =====================
    // Config & State
    // =====================
    const config = {
        canvasWidth: 500,
        canvasHeight: 650,
        playerSpeed: 2.5,
        npcBaseSpeed: 1.0,
        slipperSpeed: 10,
        pickupDistanceOffset: 10,
        boundaryY: 550,
        chaseNearCanDistance: 250,
        shakeDuration: 10,
        particleLifetime: 120,
        particleSpeed: 1.5,
        joystickMaxDist: 30,
        joystickDeadzone: 5,
        leaderboardUrl: "https://script.google.com/macros/s/AKfycbwYf83BGrHrYjEqepm5Aqvh2jsUd1FNYwtmb0CbDT1IE5cjS-8wiYp38XpE_w296D70Ow/exec"
    };

    // Game state
    const state = {
        score: 0,
        isGameOver: false,
        isPaused: false,
        messageTimer: 0,
        canWasHitThisRound: false,
        playerCarriedSlipperBack: false,
        shakeTimer: 0,
        shakeX: 0,
        shakeY: 0,
        scoreParticles: [],
        joystickActive: false,
        joystickStartX: 0,
        joystickStartY: 0,
        joystickCurrentX: 0,
        joystickCurrentY: 0,
        leaderboard: [], // Store leaderboard data
        playerName: null, // Store player name if they make it to leaderboard
        isNewHighScore: false // Track if current score is a new high score
    };

    // DOM
    const gameWrapper = document.querySelector('.game-wrap');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreValueElement = document.getElementById('scoreValue');
    const messageBox = document.getElementById('messageBox');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    const leaderboardBtn = document.getElementById('leaderboardBtn');
    const mobileControlsContainer = document.getElementById('mobileControlsContainer');
    const joystickArea = document.getElementById('joystickArea');
    const joystickThumb = document.getElementById('joystickThumb');
    const mobileThrowBtn = document.getElementById('mobile-throw-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    
    // Leaderboard DOM elements
    const leaderboardContainer = document.getElementById('leaderboardContainer');
    const leaderboardList = document.getElementById('leaderboardList');
    const leaderboardForm = document.getElementById('leaderboardForm');
    const playerNameInput = document.getElementById('playerNameInput');
    const submitScoreBtn = document.getElementById('submitScoreBtn');
    const cancelSubmitBtn = document.getElementById('cancelSubmitBtn');
    const closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');

    // Resize canvas
    canvas.width = config.canvasWidth;
    canvas.height = config.canvasHeight;

    // =====================
    // Sprites & Entities
    // =====================
    const backgroundMap = new Image();
    backgroundMap.src = 'place.png';

    const startBackground = new Image();
    startBackground.src = 'start.png';

    startBackground.onload = () => {
        startOverlay.style.backgroundImage = `url('${startBackground.src}')`;
    };

    const playerSprite = new Image(); playerSprite.src = 'avatar.png';
    const playerColumns = 3, playerRows = 3;
    let playerFrameW = 0, playerFrameH = 0;

    const npcSprite = new Image(); npcSprite.src = 'npc.png';
    const npcColumns = 4, npcRows = 4;
    let npcFrameW = 0, npcFrameH = 0;

    const canImage = new Image(); canImage.src = 'can.png';
    const slipperImage = new Image(); slipperImage.src = 'slipper.png';

    const player = {
        x: canvas.width / 2,
        y: canvas.height - 25,
        width: 55,
        height: 55,
        dir: 0,
        moving: false,
        currFrame: 1,
        frameCounter:0,
    };

    const npc = {
        x: canvas.width / 2 + 50,
        y: 190,
        width: 85,
        height: 85,
        speed: config.npcBaseSpeed,
        state: 'idle',
        carryingCan: false,
        originalX: canvas.width / 2 + 50,
        originalY: 190,
        guardRadius: 40,
        patrolRadius: 150,
        chaseReturnBuffer: 50,
        patrolTargetX: null,
        patrolTargetY: null,
        currFrame:0,
        frameCounter:0,
        dir: 0,
    };
    
    const can = {
        x: canvas.width/2,
        y: 270,
        size: 50,
        image: canImage,
        isHit: false,
        vx:0, vy:0,
        rotation:0,
        rotationSpeed:0,
        mass: 1.5,
        originalX: canvas.width/2,
        originalY: 270
    };

    const slipper = {
        x: player.x + 10,
        y: player.y - 15,
        size: 40,
        image: slipperImage,
        isHeld: true,
        speed: config.slipperSpeed,
        vx:0, vy:0,
        justThrown:false,
        throwCooldown:0,
        rotation: 0,
        rotationSpeed: 0,
    };

    const keys = { up:false, down:false, left:false, right:false, space:false };

    // =====================
    // Leaderboard Functions
    // =====================
    async function fetchLeaderboard() {
        try {
            const response = await fetch(config.leaderboardUrl + "?action=get");
            if (!response.ok) throw new Error('Failed to fetch leaderboard');
            const data = await response.json();
            if (data.success) {
                state.leaderboard = data.leaderboard || [];
                return true;
            } else {
                console.error('Error fetching leaderboard:', data.error);
                return false;
            }
        } catch (error) {
            console.error('Error fetching leaderboard:', error);
            return false;
        }
    }

    async function submitScore(name, score) {
        try {
            const response = await fetch(config.leaderboardUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `action=submit&name=${encodeURIComponent(name)}&score=${score}`
            });
            
            if (!response.ok) throw new Error('Failed to submit score');
            const data = await response.json();
            return data.success;
        } catch (error) {
            console.error('Error submitting score:', error);
            return false;
        }
    }

    function displayLeaderboard() {
        leaderboardList.innerHTML = '';
        
        if (state.leaderboard.length === 0) {
            leaderboardList.innerHTML = '<p>No scores yet. Be the first!</p>';
            return;
        }
        
        state.leaderboard.forEach((entry, index) => {
            const item = document.createElement('div');
            item.className = 'leaderboard-item';
            item.innerHTML = `
                <span>${index + 1}. ${entry.name}</span>
                <span>${entry.score}</span>
            `;
            leaderboardList.appendChild(item);
        });
    }

    function showLeaderboard() {
        state.isPaused = true;
        leaderboardContainer.style.display = 'block';
        leaderboardForm.style.display = 'none';
        displayLeaderboard();
    }

    function hideLeaderboard() {
        leaderboardContainer.style.display = 'none';
        state.isPaused = false;
    }

    function checkIfHighScore(score) {
        if (state.leaderboard.length < 10) return true;
        
        for (let i = 0; i < state.leaderboard.length; i++) {
            if (score > state.leaderboard[i].score) {
                return true;
            }
        }
        return false;
    }

    function showHighScoreForm() {
        leaderboardForm.style.display = 'block';
        playerNameInput.value = '';
        playerNameInput.focus();
    }

    // =====================
    // Helpers
    // =====================
    Math.clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    function showMessage(html, duration=180){
        messageBox.innerHTML = html;
        messageBox.style.display = 'block';
        state.messageTimer = duration;
    }
    
    function hideMessage(){ messageBox.style.display = 'none'; }

    function startShake(duration=config.shakeDuration){ state.shakeTimer = duration; }

    function applyShake(){
        if(state.shakeTimer>0){
            state.shakeTimer--;
            state.shakeX = (Math.random()-0.5)*6;
            state.shakeY = (Math.random()-0.5)*6;
        } else { state.shakeX=0; state.shakeY=0; }
    }

    // =====================
    // Initialization after sprite load
    // =====================
    playerSprite.onload = ()=>{ playerFrameW = playerSprite.width / playerColumns; playerFrameH = playerSprite.height / playerRows; };
    npcSprite.onload = ()=>{ npcFrameW = npcSprite.width / npcColumns; npcFrameH = npcSprite.height / npcRows; };

    // =====================
    // Input (Keyboard & Mobile Touch)
    // =====================
    window.addEventListener('keydown', (e)=>{
        if(state.isGameOver || state.isPaused) return;
        const key = e.key.toLowerCase();
        if(key==='w' || key==='arrowup') { keys.up=true; }
        else if(key==='s' || key==='arrowdown'){ keys.down=true; }
        else if(key==='a' || key==='arrowleft'){ keys.left=true; }
        else if(key==='d' || key==='arrowright'){ keys.right=true; }
        else if(key===' '){
            if(!keys.space && slipper.isHeld && !slipper.justThrown && player.y >= config.boundaryY){
                keys.space = true; throwSlipperTowardCan();
            }
        } else if(key==='p'){
            togglePause();
        } else if(key==='r'){
            resetGame();
        }
    });

    window.addEventListener('keyup',(e)=>{
        if(state.isGameOver || state.isPaused) return;
        const key = e.key.toLowerCase();
        if(key==='w' || key==='arrowup') keys.up=false;
        else if(key==='s' || key==='arrowdown') keys.down=false;
        else if(key==='a' || key==='arrowleft') keys.left=false;
        else if(key==='d' || key==='arrowright') keys.right=false;
        else if(key===' ') { keys.space=false; }
    });

    // Mobile Joystick Logic
    function handleJoystickMove(touchX, touchY) {
        let dx = touchX - state.joystickStartX;
        let dy = touchY - state.joystickStartY;
        const distance = Math.hypot(dx, dy);

        if (distance > config.joystickMaxDist) {
            dx = (dx / distance) * config.joystickMaxDist;
            dy = (dy / distance) * config.joystickMaxDist;
        }

        state.joystickCurrentX = dx;
        state.joystickCurrentY = dy;

        joystickThumb.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
    }

    function handleThrow(e) {
        e.preventDefault();
        if (!state.isPaused && !state.isGameOver && slipper.isHeld && !slipper.justThrown && player.y >= config.boundaryY) {
            throwSlipperTowardCan();
        }
        return false;
    }

    function setupMobileControls() {
        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            state.joystickActive = true;
            const rect = joystickArea.getBoundingClientRect();
            state.joystickStartX = rect.left + rect.width / 2;
            state.joystickStartY = rect.top + rect.height / 2;
            handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
        });

        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (state.joystickActive) {
                handleJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        });

        joystickArea.addEventListener('touchend', () => {
            state.joystickActive = false;
            state.joystickCurrentX = 0;
            state.joystickCurrentY = 0;
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            keys.up = false;
            keys.down = false;
            keys.left = false;
            keys.right = false;
        });

        mobileThrowBtn.addEventListener('touchstart', handleThrow);
        mobileThrowBtn.addEventListener('click', handleThrow);

        document.addEventListener('touchmove', (e) => {
            if (state.joystickActive || e.target === mobileThrowBtn) {
                e.preventDefault();
            }
        }, { passive: false });
    }

    // Start button
    startBtn.addEventListener('click', ()=>{
        startOverlay.style.display='none';
        state.isPaused = false;
        if (window.matchMedia("(max-width: 768px)").matches) {
            mobileControlsContainer.style.display = 'block';
        }
        startLoop();
    });

    // Leaderboard button
    leaderboardBtn.addEventListener('click', showLeaderboard);

    // Leaderboard events
    closeLeaderboardBtn.addEventListener('click', hideLeaderboard);
    
    submitScoreBtn.addEventListener('click', async () => {
        const name = playerNameInput.value.trim();
        if (name === '') {
            alert('Please enter your name');
            return;
        }
        
        const success = await submitScore(name, state.score);
        if (success) {
            alert('Score submitted successfully!');
            await fetchLeaderboard();
            hideLeaderboard();
            resetGame();
        } else {
            alert('Failed to submit score. Please try again.');
        }
    });
    
    cancelSubmitBtn.addEventListener('click', () => {
        leaderboardForm.style.display = 'none';
        hideLeaderboard();
        resetGame();
    });

    // Fullscreen button
    fullscreenBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        } else {
            if (gameWrapper.requestFullscreen) {
                gameWrapper.requestFullscreen();
            } else if (gameWrapper.mozRequestFullScreen) {
                gameWrapper.mozRequestFullScreen();
            } else if (gameWrapper.webkitRequestFullscreen) {
                gameWrapper.webkitRequestFullscreen();
            } else if (gameWrapper.msRequestFullscreen) {
                gameWrapper.msRequestFullscreen();
            }
        }
    });

    // =====================
    // Actions
    // =====================
    function throwSlipperTowardCan(){
        if(state.isPaused || state.isGameOver) return;
        if(!slipper.isHeld) return;
        slipper.isHeld = false; slipper.justThrown = true; slipper.throwCooldown = 10;
        const dx = can.x - player.x; const dy = can.y - player.y; const distance = Math.hypot(dx,dy)||1;
        slipper.vx = (dx/distance)*slipper.speed; slipper.vy = (dy/distance)*slipper.speed;
        slipper.x += slipper.vx * 0.5; slipper.y += slipper.vy * 0.5;
        slipper.rotationSpeed = (Math.random() - 0.5) * 0.5;
    }

    function togglePause(){ state.isPaused = !state.isPaused; if(state.isPaused) showMessage('Paused'); else hideMessage(); }

    // =====================
    // Update functions
    // =====================
    function updatePlayerMovement() {
        const desiredVx = (keys.left || state.joystickCurrentX < -config.joystickDeadzone) ? -1 : 
                   (keys.right || state.joystickCurrentX > config.joystickDeadzone) ? 1 : 0;
        const desiredVy = (keys.up || state.joystickCurrentY < -config.joystickDeadzone) ? -1 : 
                   (keys.down || state.joystickCurrentY > config.joystickDeadzone) ? 1 : 0;

        player.moving = (desiredVx !== 0 || desiredVy !== 0);

        if (player.moving) {
            const mag = Math.hypot(desiredVx, desiredVy);
            player.x += (desiredVx / mag) * config.playerSpeed;
            player.y += (desiredVy / mag) * config.playerSpeed;
            
            if (Math.abs(desiredVx) > Math.abs(desiredVy)) {
                player.dir = desiredVx > 0 ? 3 : 2;
            } else {
                player.dir = desiredVy > 0 ? 0 : 1;
            }
            player.frameCounter++;
            if (player.frameCounter % 10 === 0) {
                player.currFrame = (player.currFrame + 1) % playerColumns;
            }
        } else {
            player.currFrame = 1;
            player.frameCounter = 0;
        }

        player.x = Math.clamp(player.x, player.width/2, canvas.width - player.width/2);
        player.y = Math.clamp(player.y, player.height/2, canvas.height - player.height/2);
    }

    function updateSlipper(){
        if(slipper.throwCooldown>0) slipper.throwCooldown--;
        else slipper.justThrown = false;

        if(slipper.isHeld){ slipper.x = player.x + 10; slipper.y = player.y - 15; }
        else {
            slipper.x += slipper.vx; slipper.y += slipper.vy;
            slipper.vx *= 0.98; slipper.vy *= 0.98;
            slipper.rotation += slipper.rotationSpeed;
            slipper.rotationSpeed *= 0.98;

            if(slipper.x - slipper.size/2 < 0 || slipper.x + slipper.size/2 > canvas.width){ slipper.vx *= -0.7; slipper.x = Math.max(slipper.size/2, Math.min(canvas.width - slipper.size/2, slipper.x)); }
            if(slipper.y - slipper.size/2 < 0 || slipper.y + slipper.size/2 > canvas.height){ slipper.vy *= -0.7; slipper.y = Math.max(slipper.size/2, Math.min(canvas.height - slipper.size/2, canvas.height)); }

            const dx = slipper.x - can.x; const dy = slipper.y - can.y; const dist = Math.hypot(dx,dy);
            const minDist = slipper.size/2 + can.size/2;
            if(dist < minDist && !can.isHit){
                can.isHit = true; state.canWasHitThisRound = true; startShake(8);
                const nx = dx/dist; const ny = dy/dist;
                const relVx = slipper.vx - can.vx; const relVy = slipper.vy - can.vy;
                const impulse = 2 * (relVx*nx + relVy*ny) / (1/slipper.size + 1/can.mass);
                slipper.vx -= impulse * nx / slipper.size; 
                slipper.vy -= impulse * ny / slipper.size; 
                can.vx += impulse * nx / can.mass; can.vy += impulse * ny / can.mass;
                const overlap = minDist - dist + 1; slipper.x += nx*overlap; slipper.y += ny*overlap;
                npc.state = 'movingToCan';
            }
            if(Math.abs(slipper.vx) < 0.2 && Math.abs(slipper.vy) < 0.2){ slipper.vx=0; slipper.vy=0; }
        }

        if(!slipper.isHeld && !slipper.justThrown){
            const dxp = player.x - slipper.x; const dyp = player.y - slipper.y; const d = Math.hypot(dxp,dyp);
            const pickupRadius = player.width/2 + slipper.size/2 + config.pickupDistanceOffset;
            if(d < pickupRadius){
                slipper.isHeld = true; slipper.vx=0; slipper.vy=0;
                slipper.rotation = 0; slipper.rotationSpeed = 0;
                if(state.canWasHitThisRound) state.playerCarriedSlipperBack = true;
            }
        }
    }

    function updateCanPhysics(){
        if(can.isHit){
            can.x += can.vx; can.y += can.vy; can.rotation += can.rotationSpeed;
            can.vx *= 0.95; can.vy *= 0.95; can.rotationSpeed *= 0.95;
            if(can.x - can.size/2 < 0 || can.x + can.size/2 > canvas.width){ can.vx *= -0.5; can.x = Math.max(can.size/2, Math.min(canvas.width - can.size/2, can.x)); }
            if(can.y - can.size/2 < 0 || can.y + can.size/2 > canvas.height){ can.vy *= -0.5; can.y = Math.max(can.size/2, Math.min(canvas.height - can.size/2, canvas.height)); }
            if(Math.abs(can.vx)<0.1 && Math.abs(can.vy)<0.1 && Math.abs(can.rotationSpeed)<0.01){ can.vx=0; can.vy=0; can.rotationSpeed=0; }
        }

        if(state.playerCarriedSlipperBack && player.y >= config.boundaryY){
            state.score++; 
            scoreValueElement.textContent = state.score; 
            state.canWasHitThisRound = false; 
            state.playerCarriedSlipperBack = false;
            
            state.scoreParticles.push({
                x: player.x,
                y: player.y,
                alpha: 1.0,
                life: config.particleLifetime
            });

            if (state.score % 2 === 0) {
                npc.patrolRadius = Math.max(20, npc.patrolRadius - 5);
                npc.chaseReturnBuffer = Math.max(10, npc.chaseReturnBuffer - 5);
            }

            can.x = can.originalX; can.y = can.originalY; can.isHit=false; can.vx=0; can.vy=0; can.rotation=0; can.rotationSpeed=0;
            npc.x = npc.originalX; npc.y = npc.originalY; npc.state='idle'; npc.carryingCan=false; npc.speed = config.npcBaseSpeed + Math.floor(state.score/3)*0.3;
        }
    }

    function updateNPCBehavior(){
        let npcMoving=false;
        const distPlayerToCan = Math.hypot(player.x - can.x, player.y - can.y);
        const distPlayerToSlipper = Math.hypot(player.x - slipper.x, player.y - slipper.y);

        if (slipper.isHeld && !can.isHit && distPlayerToCan < config.chaseNearCanDistance && npc.state !== 'chasing') {
            npc.state = 'chasing';
            npc.patrolTargetX = null;
            npc.patrolTargetY = null;
        }
        else if (!slipper.isHeld && npc.state === 'guardingSlipper' && distPlayerToSlipper < npc.guardRadius) {
            npc.state = 'chasing';
            npc.patrolTargetX = null;
            npc.patrolTargetY = null;
        }

        if(npc.state === 'idle') {
            const dx = player.x - npc.x;
            const dy = player.y - npc.y;
            npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);
        }
        
        switch(npc.state){
            case 'movingToCan':
                npcMoving = true;
                {
                    const dx = can.x - npc.x;
                    const dy = can.y - npc.y;
                    const dist = Math.hypot(dx,dy)||1;
                    npc.dir = Math.abs(dx)>Math.abs(dy) ? (dx>0?2:1) : (dy>0?0:3);
                    if(dist > 5){
                        npc.x += (dx/dist)*npc.speed;
                        npc.y += (dy/dist)*npc.speed;
                    } else {
                        npc.carryingCan = true;
                        npc.state = 'returningCan';
                    }
                }
                break;
            case 'returningCan':
                npcMoving = true;
                {
                    const dx = can.originalX - npc.x;
                    const dy = can.originalY - npc.y;
                    const dist = Math.hypot(dx, dy) || 1;

                    npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);

                    if(dist < 5){ 
                        can.x = can.originalX;
                        can.y = can.originalY;
                        can.isHit = false;
                        can.rotation = 0;
                        npc.carryingCan = false;
                        npc.state = 'guardingSlipper';
                    } else {
                        npc.x += (dx/dist)*npc.speed;
                        npc.y += (dy/dist)*npc.speed;
                        can.x = npc.x;
                        can.y = npc.y;
                    }
                }
                break;
            case 'guardingSlipper':
                npcMoving = true;
                if(npc.patrolTargetX===null || npc.patrolTargetY===null){
                    const angle = Math.random()*Math.PI*2;
                    const distance = Math.random()*npc.patrolRadius;
                    npc.patrolTargetX = slipper.x + Math.cos(angle)*distance;
                    npc.patrolTargetY = slipper.y + Math.sin(angle)*distance;
                }
                {
                    const dx = npc.patrolTargetX - npc.x; const dy = npc.patrolTargetY - npc.y; const dist = Math.hypot(dx,dy)||1;
                    npc.dir = Math.abs(dx)>Math.abs(dy) ? (dx>0?2:1) : (dy>0?0:3);
                    if(dist > 5){ npc.x += (dx/dist)*npc.speed; npc.y += (dy/dist)*npc.speed; }
                    else { npc.patrolTargetX=null; npc.patrolTargetY=null; }
                }
                break;
            case 'chasing':
                npcMoving = true;
                {
                    const dx = player.x - npc.x; const dy = player.y - npc.y; const dist = Math.hypot(dx,dy)||1;
                    npc.dir = Math.abs(dx)>Math.abs(dy) ? (dx>0?2:1) : (dy>0?0:3);
                    if(dist > npc.width/2) { npc.x += (dx/dist)*npc.speed; npc.y += (dy/dist)*npc.speed; }
                }
                
                const tolerance = 43;
                const currentDistToPlayer = Math.hypot(player.x - npc.x, player.y - npc.y);
                
                if (currentDistToPlayer < tolerance) {
                    state.isGameOver = true;
                    startShake();
                    
                    // Check if this is a high score
                    if (checkIfHighScore(state.score)) {
                        state.isNewHighScore = true;
                        showMessage(`<span style="color:red; font-weight:bold; font-size: 2em; font-family: 'Press Start 2P', cursive;">Game Over!</span><br><span style="color:yellow; font-size: 1.5em; font-family: 'Press Start 2P', cursive;">${state.score}!!</span><br><span style="color:lightgreen; font-size: 1em; font-family: 'Press Start 2P', cursive;">New High Score!</span><br><br><button id="playAgainBtn">Retry</button>`, 0);
                    } else {
                        showMessage(`<span style="color:red; font-weight:bold; font-size: 2em; font-family: 'Press Start 2P', cursive;">Game Over!</span><br><span style="color:yellow; font-size: 1.5em; font-family: 'Press Start 2P', cursive;">${state.score}!!</span><br><br><button id="playAgainBtn">Retry</button>`, 0);
                    }
                    
                    document.getElementById('playAgainBtn').addEventListener('click', resetGame);
                }
                
                if (slipper.isHeld && !can.isHit) {
                    if (distPlayerToCan >= config.chaseNearCanDistance) {
                        npc.state = 'returningToOrigin';
                        npc.patrolTargetX = null;
                        npc.patrolTargetY = null;
                    }
                }
                else if (!slipper.isHeld) {
                    if (distPlayerToSlipper > npc.guardRadius + npc.chaseReturnBuffer) {
                        npc.state = 'guardingSlipper';
                        npc.patrolTargetX = null;
                        npc.patrolTargetY = null;
                    }
                }
                break;
            case 'returningToOrigin':
                npcMoving = true;
                {
                    const dx = npc.originalX - npc.x;
                    const dy = npc.originalY - npc.y;
                    const dist = Math.hypot(dx, dy) || 1;

                    npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);

                    if (dist > 5) {
                        npc.x += (dx / dist) * npc.speed;
                        npc.y += (dy / dist) * npc.speed;
                    } else {
                        npc.x = npc.originalX;
                        npc.y = npc.originalY;
                        npc.state = 'idle';
                        npc.patrolTargetX = null;
                        npc.patrolTargetY = null;
                    }
                }
                break;
        }

        if(npcMoving){ npc.frameCounter++; if(npc.frameCounter%15===0) npc.currFrame = (npc.currFrame+1) % npcColumns; }
        else npc.currFrame = 0;
    }

    function updateAnimations(){
        for (let i = state.scoreParticles.length - 1; i >= 0; i--) {
            const particle = state.scoreParticles[i];
            particle.y -= config.particleSpeed;
            particle.alpha -= 1 / config.particleLifetime;

            if (particle.alpha <= 0) {
                state.scoreParticles.splice(i, 1);
            }
        }
    }

    function updateAll(){
        if(state.isPaused || state.isGameOver) return;
        if(state.messageTimer>0){ state.messageTimer--; if(state.messageTimer===0) hideMessage(); }

        applyShake();

        updatePlayerMovement();
        updateSlipper();
        updateCanPhysics();
        updateNPCBehavior();
        updateAnimations();
    }

    // =====================
    // Drawing
    // =====================
    function drawBackground(){
        if (backgroundMap.complete) {
            ctx.drawImage(backgroundMap, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle='forestgreen';
            ctx.fillRect(0,0,canvas.width,canvas.height);
        }
    }
    function drawBoundary(){ ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,config.boundaryY); ctx.lineTo(config.canvasWidth, config.boundaryY); ctx.stroke(); }
    
    function drawCan(){
        if(!npc.carryingCan){
            if (can.image.complete) {
                ctx.save();
                ctx.translate(can.x, can.y);
                ctx.rotate(can.rotation);
                ctx.drawImage(can.image, -can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            } else {
                ctx.save(); ctx.translate(can.x, can.y); ctx.rotate(can.rotation);
                ctx.fillStyle = 'gray'; ctx.fillRect(-can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            }
        }
    }

    function drawSlipper(){
        if (slipper.image.complete) {
            ctx.save();
            ctx.translate(slipper.x, slipper.y);
            ctx.rotate(slipper.rotation);
            ctx.drawImage(slipper.image, -slipper.size/2, -slipper.size/2, slipper.size, slipper.size);
            ctx.restore();
        } else {
            ctx.save(); ctx.translate(slipper.x, slipper.y); ctx.rotate(slipper.rotation);
            ctx.fillStyle = 'brown'; ctx.fillRect(-slipper.size/2, -slipper.size/2, slipper.size, slipper.size);
            ctx.restore();
        }
    }

    function drawNPC(){
        if(!npcSprite.complete) return;
        const dw = npc.width, dh = npc.height;
        ctx.save();
        ctx.drawImage(npcSprite, npc.currFrame*npcFrameW, (npc.dir||0)*npcFrameH, npcFrameW, npcFrameH, npc.x - dw/2, npc.y - dh/2, dw, dh);
        
        if(npc.carryingCan){
            if (can.image.complete) {
                ctx.save();
                ctx.translate(npc.x, npc.y - 30);
                ctx.rotate(can.rotation);
                ctx.drawImage(can.image, -can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            } else {
                ctx.save(); ctx.translate(npc.x, npc.y-30); ctx.rotate(can.rotation);
                ctx.fillStyle = 'gray'; ctx.fillRect(-can.size/2, -can.size/2, can.size, can.size);
                ctx.restore();
            }
        }
        ctx.restore();
    }

    function drawPlayer(){
        if(!playerSprite.complete) return;
        const row = (player.dir===2||player.dir===3)?2:player.dir;
        const flip = player.dir===3;
        const frame = player.moving ? player.currFrame : 1;
        const sx = Math.floor(frame*playerFrameW);
        const sy = Math.floor(row*playerFrameH);
        const sw = Math.floor(playerFrameW-1);
        const sh = Math.floor(playerFrameH);
        ctx.save();
        if(flip){
            ctx.scale(-1,1);
            ctx.drawImage(playerSprite, sx, sy, sw, sh, -player.x - player.width/2, player.y - player.height/2, player.width, player.height);
        } else {
            ctx.drawImage(playerSprite, sx, sy, sw, sh, player.x - player.width/2, player.y - player.height/2, player.width, player.height);
        }
        ctx.restore();
    }

    function drawScoreParticles(){
        ctx.save();
        ctx.font = 'bold 36px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        state.scoreParticles.forEach(particle => {
            ctx.globalAlpha = particle.alpha;
            ctx.fillStyle = `rgba(255, 255, 0, ${particle.alpha})`;
            ctx.shadowColor = `rgba(255, 255, 0, ${particle.alpha})`;
            ctx.fillText('+1', particle.x, particle.y);
        });
        ctx.restore();
    }

    function drawAll(){
        ctx.save(); ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.translate(state.shakeX, state.shakeY);
        drawBackground(); drawBoundary(); drawNPC(); drawCan(); drawSlipper(); drawPlayer();
        drawScoreParticles();
        ctx.restore();
    }

    // =====================
    // Game loop
    // =====================
    let loopId = null;
    function loop(){ updateAll(); drawAll(); loopId = requestAnimationFrame(loop); }
    function startLoop(){
        if(loopId) cancelAnimationFrame(loopId);
        loop();
    }

    function resetGame(){
        // If we have a new high score, show the submission form
        if (state.isNewHighScore) {
            state.isNewHighScore = false;
            showLeaderboard();
            showHighScoreForm();
            return;
        }
        
        state.isGameOver=false;
        state.isPaused=false;
        state.score=0;
        scoreValueElement.textContent = 0;
        hideMessage();

        player.x = canvas.width/2; player.y = canvas.height - 25; player.moving=false; player.currFrame=1;
        slipper.isHeld = true; slipper.vx=0; slipper.vy=0; slipper.x = player.x + 10; slipper.y = player.y - 15; slipper.justThrown=false; slipper.throwCooldown=0;
        slipper.rotation = 0; slipper.rotationSpeed = 0;
        can.x = can.originalX; can.y = can.originalY; can.isHit=false; can.vx=0; can.vy=0; can.rotation=0; can.rotationSpeed=0;
        npc.x = npc.originalX; npc.y = npc.originalY; npc.state='idle'; npc.carryingCan=false;
        npc.speed = config.npcBaseSpeed;
        npc.patrolRadius = 50;
        npc.chaseReturnBuffer = 50;
        state.canWasHitThisRound=false; state.playerCarriedSlipperBack=false;
        state.scoreParticles = [];

        const dx = player.x - npc.x;
        const dy = player.y - npc.y;
        npc.dir = Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 2 : 1) : (dy > 0 ? 0 : 3);

        startOverlay.style.display='flex';
        mobileControlsContainer.style.display = 'none';

        if(loopId) cancelAnimationFrame(loopId);
        loopId = null;
    }

    window.resetGame = resetGame;
    window.startGame = ()=>{ startOverlay.style.display='none'; startLoop(); };

    const helpIcon = document.getElementById('help-icon');
    const helpOverlay = document.getElementById('help-overlay');
    const closeHelp = document.getElementById('close-help');

    helpIcon.addEventListener('click', () => {
        state.isPaused = true;
        helpOverlay.style.display = 'flex';
    });
    closeHelp.addEventListener('click', () => {
        state.isPaused = false;
        helpOverlay.style.display = 'none';
    });

    // Initial setup when the page loads
    window.addEventListener('load', async () => {
        // Fetch leaderboard data on page load
        await fetchLeaderboard();
        
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        if (isMobile || window.innerWidth <= 768) {
            setupMobileControls();
        }
        resetGame();
    });

    const observer = new MutationObserver(()=>{ const btn = document.getElementById('playAgainBtn'); if(btn) btn.addEventListener('click', resetGame); });
    observer.observe(messageBox, {childList:true, subtree:true});
</script>
</body>
</html>
